* (1) Analizar los fundamentos del patrón Saga, diferenciando claramente entre los modelos de Coreografía y Orquestación, e investigar la necesidad de las acciones compensatorias (compensating transactions) para el rollback lógico de transacciones distribuidas.
* (2) Investigar las diferencias fundamentales y los casos de uso entre el patrón Saga y el Two-Phase Commit (2PC), enfocándose en las ventajas y desventajas en términos de latencia, bloqueo y disponibilidad en sistemas distribuidos.
* (3) Estudiar la infraestructura de comunicación subyacente a las Sagas, incluyendo la Arquitectura Orientada a Eventos (EDA), el rol de los message brokers (Kafka, RabbitMQ) y los requisitos de garantías de entrega e idempotencia en los consumidores de microservicios.
* (4) Examinar la relación y distinción conceptual entre el Event Sourcing y el patrón Saga, y cómo estos patrones pueden coexistir o complementarse en el diseño de una arquitectura de microservicios.
* (5) Recopilar estrategias prácticas para lograr la Consistencia Eventual, incluyendo la aplicación de compensating transactions y técnicas de resiliencia como el Circuit Breaker, Retry Pattern, y el uso de Dead Letter Queues para manejar fallos parciales.
* (6) Evaluar cómo los principios de Domain-Driven Design (DDD), específicamente Bounded Contexts y Context Mapping, guían la división de servicios y la segmentación de bases de datos necesaria para implementar Sagas de manera efectiva.
* (7) Identificar y analizar frameworks y librerías clave que ofrecen soporte para la implementación real del patrón Saga (ej. Temporal.io, Camunda, Axon Framework), buscando ejemplos de código que ilustren la complejidad práctica de la orquestación y la coreografía.
* (8) Comparar el patrón Saga con sus principales alternativas (ej. TCC - Try-Confirm/Cancel, motores de orquestación de workflows, CQRS) y determinar los trade-offs arquitectónicos y el coste de complejidad que implica su adopción en contraposición a un monolito modular.
